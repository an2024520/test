// ============================================================
// Cloudflare Worker 纯净版 (PRO Clean & Secure)
// 版本: v4.0 Final
// 审计: 已移除外部 UI 依赖、遥测暗门、模糊匹配漏洞
// 功能: GitHub 全链路加速 + JSON/Shell 动态注入 + 302 跳转接管
// ============================================================

// 1. 严格白名单 (只允许 GitHub 官方核心域名)
// 拒绝 'evil-git.com' 等包含 git 关键字的钓鱼域名
const WHITELIST_DOMAINS = new Set([
  'github.com',
  'raw.githubusercontent.com',
  'gist.githubusercontent.com',
  'api.github.com',
  'assets-cdn.github.com',
  'codeload.github.com',
  'objects.githubusercontent.com', // 关键: Release 下载文件通常存储在此 (AWS S3)
  'github-cloud.s3.amazonaws.com', // 关键: 部分旧版 Release 存储在此
  'github-production-release-asset-2e65be.s3.amazonaws.com' // 关键: 生产环境存储桶
]);

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

/**
 * 核心请求处理逻辑
 */
async function handleRequest(request) {
  const url = new URL(request.url);
  const workerUrl = url.origin; // 获取当前 Worker 域名

  // --- 路径解析与清洗 ---
  // 移除开头的 '/'，获取目标 URL
  let targetPath = url.pathname.substring(1); 

  // [净化 1] 移除 UI 依赖
  // 如果没有路径，直接返回纯文本状态，不加载任何外部 HTML/JS
  if (!targetPath) {
    return new Response("PRO Proxy System: Operational\nMode: Secure IPv6 Adapter", { 
      status: 200, 
      headers: { 'content-type': 'text/plain;charset=UTF-8' } 
    });
  }

  // [净化 2] 移除 'perl-pe-para' 等暗门接口
  // 此处没有任何特殊路径判断，所有请求必须走正规流程

  // 处理双重代理前缀 (Cleaning)
  const selfPrefix = workerUrl + '/';
  if (request.url.includes(selfPrefix + selfPrefix)) {
      targetPath = request.url.split(selfPrefix).pop(); 
  }

  // 补全 HTTPS 协议
  if (!targetPath.startsWith('http')) {
      targetPath = 'https://' + targetPath;
  }

  // --- 域名安全校验 ---
  let targetUrlObj;
  try {
    targetUrlObj = new URL(targetPath);
  } catch (e) {
    return new Response("Invalid URL", { status: 400 });
  }

  // [净化 3] 严格白名单校验
  if (!WHITELIST_DOMAINS.has(targetUrlObj.hostname)) {
    // 允许 AWS S3 的特定存储桶模式 (因为 GitHub Release 跳转的 S3 域名很长且多变)
    if (!targetUrlObj.hostname.endsWith('.s3.amazonaws.com')) {
        return new Response(`Forbidden: Domain '${targetUrlObj.hostname}' is not whitelisted.`, { status: 403 });
    }
  }

  // --- 构造请求 ---
  // 使用 manual 模式，禁止 Worker 自动跟随跳转，必须由我们接管跳转逻辑
  const newRequest = new Request(targetPath, {
    method: request.method,
    headers: request.headers,
    redirect: 'manual' 
  });

  try {
    const response = await fetch(newRequest);
    const newHeaders = new Headers(response.headers);
    const status = response.status;

    // ============================================================
    // 功能 A: 接管 301/302 跳转 (修复 Release 下载失败)
    // ============================================================
    if (status >= 300 && status < 400 && newHeaders.has('Location')) {
      const originalLocation = newHeaders.get('Location');
      // 强制将跳转地址也加上 Worker 前缀
      // 这样 VPS 请求跳转后的 S3 地址时，流量依然走 Worker，解决 IPv6 问题
      newHeaders.set('Location', `${workerUrl}/${originalLocation}`);
      return new Response(response.body, {
        status: status,
        statusText: response.statusText,
        headers: newHeaders
      });
    }

    // ============================================================
    // 功能 B: 智能内容注入 (修复脚本和 API 下载链接)
    // ============================================================
    const contentType = newHeaders.get('content-type');
    const shouldRewrite = contentType && (
        contentType.includes('application/x-sh') || 
        contentType.includes('text/plain') || 
        contentType.includes('application/json') || // [关键] 拦截 GitHub API JSON
        targetPath.endsWith('.sh')
    );

    if (shouldRewrite) {
      let bodyText = await response.text();
      
      // 正则: 匹配 http/https 链接
      const urlRegex = /(https?:\/\/[^\s"'`()<>]+)/g;

      bodyText = bodyText.replace(urlRegex, (match) => {
        try {
          const linkUrl = new URL(match);
          // 再次校验链接内的域名是否在白名单，防止误伤
          if (WHITELIST_DOMAINS.has(linkUrl.hostname) || linkUrl.hostname.endsWith('.s3.amazonaws.com')) {
            return `${workerUrl}/${match}`;
          }
          return match;
        } catch (e) { return match; }
      });

      newHeaders.delete('content-length');
      return new Response(bodyText, {
        status: status,
        statusText: response.statusText,
        headers: newHeaders
      });
    }

    // 二进制文件直接透传
    return new Response(response.body, {
      status: status,
      statusText: response.statusText,
      headers: newHeaders
    });

  } catch (e) {
    return new Response('Proxy Error: ' + e.message, { status: 500 });
  }
}
